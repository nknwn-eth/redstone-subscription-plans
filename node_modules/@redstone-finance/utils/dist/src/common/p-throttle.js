"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pThrottle = void 0;
exports.withRateLimiter = withRateLimiter;
const pThrottle = ({ limit, interval, strict, onDelay, }) => {
    if (!Number.isFinite(limit)) {
        throw new TypeError("Expected `limit` to be a finite number");
    }
    if (!Number.isFinite(interval)) {
        throw new TypeError("Expected `interval` to be a finite number");
    }
    const queue = new Map();
    let currentTick = 0;
    let activeCount = 0;
    function windowedDelay() {
        const now = Date.now();
        if (now - currentTick > interval) {
            activeCount = 1;
            currentTick = now;
            return 0;
        }
        if (activeCount < limit) {
            activeCount++;
        }
        else {
            currentTick += interval;
            activeCount = 1;
        }
        return currentTick - now;
    }
    const strictTicks = [];
    function strictDelay() {
        const now = Date.now();
        if (strictTicks.length > 0 && now - strictTicks.at(-1) > interval) {
            strictTicks.length = 0;
        }
        if (strictTicks.length < limit) {
            strictTicks.push(now);
            return 0;
        }
        const nextExecutionTime = strictTicks[0] + interval;
        strictTicks.shift();
        strictTicks.push(nextExecutionTime);
        return Math.max(0, nextExecutionTime - now);
    }
    const getDelay = strict ? strictDelay : windowedDelay;
    return (function_) => {
        const throttled = function (...arguments_) {
            if (!throttled.isEnabled) {
                return (async () => function_.apply(this, arguments_))();
            }
            let timeoutId;
            return new Promise((resolve, reject) => {
                const execute = () => {
                    resolve(function_.apply(this, arguments_));
                    queue.delete(timeoutId);
                };
                const delay = getDelay();
                if (delay > 0) {
                    timeoutId = setTimeout(execute, delay);
                    queue.set(timeoutId, reject);
                    onDelay?.();
                }
                else {
                    execute();
                }
            });
        };
        throttled.isEnabled = true;
        Object.defineProperty(throttled, "queueSize", {
            get() {
                return queue.size;
            },
        });
        return throttled;
    };
};
exports.pThrottle = pThrottle;
function withRateLimiter(fn, pThrottleOpts) {
    const limiter = (0, exports.pThrottle)(pThrottleOpts);
    return limiter(fn);
}
//# sourceMappingURL=p-throttle.js.map