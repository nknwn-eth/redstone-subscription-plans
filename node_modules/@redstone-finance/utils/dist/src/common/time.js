"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.intervalMsToCronFormat = exports.msToHours = exports.hourToMs = exports.minToMs = exports.msToMin = exports.sleep = exports.timeout = exports.timeoutOrResult = void 0;
const timeoutOrResult = async (prom, timeoutMS, customErrorMessage, timeoutCallback) => {
    return await (timeoutMS
        ? (0, exports.timeout)(prom, timeoutMS, customErrorMessage, timeoutCallback)
        : prom);
};
exports.timeoutOrResult = timeoutOrResult;
const timeout = async (prom, timeoutMS, customErrorMessage, timeoutCallback) => {
    let timer;
    try {
        return await Promise.race([
            prom,
            new Promise((resolve, reject) => (timer = setTimeout(() => {
                if (timeoutCallback) {
                    return timeoutCallback(resolve, reject);
                }
                reject(new Error(customErrorMessage ?? `Timeout error ${timeoutMS} [MS]`));
            }, timeoutMS))),
        ]);
    }
    finally {
        clearTimeout(timer);
    }
};
exports.timeout = timeout;
const sleep = (ms) => new Promise((resolve, _rejects) => setTimeout(resolve, ms));
exports.sleep = sleep;
const msToMin = (ms) => ms / 60_000;
exports.msToMin = msToMin;
const minToMs = (min) => min * 60_000;
exports.minToMs = minToMs;
const hourToMs = (hours) => hours * 3_600_000;
exports.hourToMs = hourToMs;
const msToHours = (ms) => ms / 3_600_000;
exports.msToHours = msToHours;
const intervalMsToCronFormat = (intervalMs) => {
    if (intervalMs == 60_000) {
        return `0 * * * * *`;
    }
    return `*/${intervalMs / 1000} * * * * *`;
};
exports.intervalMsToCronFormat = intervalMsToCronFormat;
//# sourceMappingURL=time.js.map