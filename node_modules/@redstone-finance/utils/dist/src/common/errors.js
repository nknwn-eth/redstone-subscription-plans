"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertWithLog = void 0;
exports.assert = assert;
exports.assertThenReturn = assertThenReturn;
exports.assertThenReturnOrFail = assertThenReturnOrFail;
exports.stringifyError = stringifyError;
exports.simplifyErrorMessage = simplifyErrorMessage;
const axios_1 = __importDefault(require("axios"));
const consola_1 = require("consola");
const ethers_1 = require("ethers");
const logger_1 = require("../logger");
const retry_1 = require("./retry");
function assert(value, errMsg, unrecoverable = false) {
    if (!value) {
        throw new (unrecoverable ? retry_1.UnrecoverableError : Error)(`Assertion failed: ${errMsg}`);
    }
}
function assertThenReturn(value, errMsg) {
    if (!value) {
        throw new Error(`Assertion failed: ${errMsg}`);
    }
    return value;
}
function assertThenReturnOrFail(value, errors, errMsg, failOnError) {
    if (errors.length > 0) {
        const error = new AggregateError(errors, errMsg);
        if (failOnError) {
            throw error;
        }
        else {
            (0, exports.assertWithLog)(false, stringifyError(error));
        }
    }
    return value;
}
const assertWithLog = (condition, errMsg) => {
    const logger = (0, logger_1.loggerFactory)("utils/errors");
    if (!condition) {
        logger.error(`Assertion failed: ${errMsg}`);
    }
};
exports.assertWithLog = assertWithLog;
let trace;
const showStack = (stack) => {
    if (!stack) {
        return "";
    }
    trace ??= (0, logger_1.getLogLevel)() >= consola_1.LogLevel.Trace;
    if (trace) {
        return stack + ";";
    }
    return "";
};
const ethers_5_7_errorCodes = Object.values(ethers_1.ethers.errors);
function isEthers_5_7_Error(error) {
    return (typeof error === "object" &&
        error !== null &&
        "code" in error &&
        typeof error.code === "string" &&
        ethers_5_7_errorCodes.includes(error.code));
}
const ethers_5_7_ErrorProps = [
    "code",
    "reason",
    "url",
    "requestBody",
    "timeout",
    "method",
    "address",
    "args",
    "errorSignature",
];
function stringifyError(e, noStack = false) {
    try {
        const error = e;
        if (error === undefined) {
            return "undefined";
        }
        else if (error instanceof AggregateError) {
            const errorMessages = error.errors.map((e) => stringifyError(e, noStack));
            return `AggregateError: ${error.message ? error.message : "<no message>"}, errors: ${errorMessages.join("; ")}`;
        }
        else if (axios_1.default.isAxiosError(error)) {
            const urlAsString = `url: ${JSON.stringify(error.config?.url)}`;
            const dataAsString = `data: ${JSON.stringify(error.response?.data)}`;
            const message = `${urlAsString}, ${dataAsString}, ${error.message}`;
            return noStack ? message : `${message}, ${showStack(error.stack)}`;
        }
        else if (isEthers_5_7_Error(error)) {
            return ("[Ethers 5.7 Error]" +
                ethers_5_7_ErrorProps
                    .filter((prop) => Object.hasOwn(error, prop))
                    .map((prop) => `[${prop}: ${error[prop]}]`)
                    .join("") +
                showStack(error.stack));
        }
        else if (error instanceof Error) {
            const causeString = error.cause
                ? `cause: ${stringifyError(error.cause, noStack)}`
                : "";
            return [error.message, noStack ? "" : showStack(error.stack), causeString]
                .filter((str) => str.length > 0)
                .join(" ");
        }
        else if (typeof error.toJSON === "function") {
            return JSON.stringify(error.toJSON());
        }
        else {
            return `Error couldn't be handled by the stringifyError function: ${String(e)}`;
        }
    }
    catch (handlingError) {
        return `StringifyError thrown error: ${String(handlingError)} when stringifying error :${String(e)}`;
    }
}
function simplifyErrorMessage(error) {
    if (error instanceof AggregateError) {
        const errorMessages = new Set();
        for (const err of error.errors) {
            const errorString = String(err);
            const pattern = "Original error: AggregateError: <no message>, errors:";
            const patternPos = errorString.indexOf(pattern);
            const startIndex = patternPos !== -1 ? patternPos + pattern.length : 0;
            const endPos = errorString.indexOf("\n", startIndex);
            const endIndex = endPos === -1 ? errorString.length : endPos;
            const shortenedError = errorString.substring(startIndex, endIndex).trim();
            errorMessages.add(shortenedError);
        }
        return Array.from(errorMessages).join("\n");
    }
    else {
        return stringifyError(error);
    }
}
//# sourceMappingURL=errors.js.map