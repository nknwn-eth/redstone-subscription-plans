"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForSuccess = exports.UnrecoverableAggregateError = exports.isErrorUnrecoverable = exports.UnrecoverableError = void 0;
exports.retry = retry;
const logger_1 = require("../logger");
const errors_1 = require("./errors");
const time_1 = require("./time");
const logger = (0, logger_1.loggerFactory)("retry");
class UnrecoverableError extends Error {
    unrecoverable = true;
}
exports.UnrecoverableError = UnrecoverableError;
const isErrorUnrecoverable = (err) => !!err.unrecoverable;
exports.isErrorUnrecoverable = isErrorUnrecoverable;
class UnrecoverableAggregateError extends AggregateError {
    unrecoverable = true;
}
exports.UnrecoverableAggregateError = UnrecoverableAggregateError;
function retry(config) {
    if (config.maxRetries === 0) {
        throw new Error(`Setting 'config.maxRetries' to 0 will never call the underlying function`);
    }
    return async (...args) => {
        const fnName = config.fnName ?? config.fn.name;
        const errors = [];
        let i = 0;
        while (i < config.maxRetries) {
            try {
                return await config.fn(...args);
            }
            catch (e) {
                ++i;
                errors.push(e);
                config.logger?.(`Retry ${i}/${config.maxRetries}; Function ${fnName} failed. ${(0, errors_1.stringifyError)(e)}`);
                if ((0, exports.isErrorUnrecoverable)(e)) {
                    break;
                }
                if (config.waitBetweenMs && i !== config.maxRetries) {
                    const sleepTimeBackOffMultiplier = config.backOff
                        ? Math.pow(config.backOff.backOffBase, i - 1)
                        : 1;
                    const sleepTime = config.waitBetweenMs * sleepTimeBackOffMultiplier;
                    config.logger?.(`Waiting ${sleepTime / 1000} s. for the next retry...`);
                    await (0, time_1.sleep)(sleepTime);
                }
            }
        }
        throw new AggregateError(errors, `Retry failed after ${i} attempts of ${fnName}`);
    };
}
const waitForSuccess = async (cond, count, errorMessage, sleepTimeMs = 5000, description = "") => {
    const logPrefix = description ? `[${description}] ` : "";
    let waitCounter = 0;
    while (!(await cond(waitCounter))) {
        if (++waitCounter < count) {
            logger.debug(`${logPrefix}Waiting ${sleepTimeMs} [ms]...`);
            await (0, time_1.sleep)(sleepTimeMs);
        }
        else {
            throw new Error(errorMessage);
        }
    }
    if (!waitCounter) {
        return;
    }
    logger.log(`${logPrefix}Did wait ${sleepTimeMs * waitCounter} [ms] in total`);
};
exports.waitForSuccess = waitForSuccess;
//# sourceMappingURL=retry.js.map