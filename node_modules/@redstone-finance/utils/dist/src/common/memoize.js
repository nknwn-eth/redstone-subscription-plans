"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.memoize = memoize;
const errors_1 = require("./errors");
const EXPECTED_MAX_CACHE_ENTRIES_PER_FN = 100_000;
const EXPECTED_MAX_CACHE_KEY_LENGTH_PER_FN = 10_000;
const CLEAN_EVERY_N_ITERATION_DEFAULT = 1;
function memoize({ functionToMemoize, ttl, cacheKeyBuilder = (...args) => JSON.stringify(args), cacheReporter = () => { }, cleanEveryNIteration = CLEAN_EVERY_N_ITERATION_DEFAULT, }) {
    const cache = {};
    let iterationCounter = 0;
    return (async (...args) => {
        const cacheKey = await cacheKeyBuilder(...args);
        (0, errors_1.assertWithLog)(cacheKey.length < EXPECTED_MAX_CACHE_KEY_LENGTH_PER_FN, `Assumed cache key will not be longer than ${EXPECTED_MAX_CACHE_KEY_LENGTH_PER_FN}. Suspicious key ${cacheKey}`);
        iterationCounter = (iterationCounter + 1) % cleanEveryNIteration;
        if (iterationCounter == 0) {
            cleanStaleCacheEntries(cache, ttl);
        }
        const isMiss = !cache[cacheKey] || Date.now() - cache[cacheKey].lastSet > ttl;
        if (isMiss) {
            cache[cacheKey] = {
                lastSet: Date.now(),
                promise: functionToMemoize(...args).catch((err) => {
                    delete cache[cacheKey];
                    throw err;
                }),
            };
        }
        cacheReporter(isMiss);
        return await cache[cacheKey].promise;
    });
}
const cleanStaleCacheEntries = (cache, ttl) => {
    const now = Date.now();
    const cacheKeys = Object.keys(cache);
    (0, errors_1.assertWithLog)(cacheKeys.length < EXPECTED_MAX_CACHE_ENTRIES_PER_FN, `Assumed cache key space will not grow over ${EXPECTED_MAX_CACHE_ENTRIES_PER_FN} but is ${cacheKeys.length}`);
    for (const key of cacheKeys) {
        if (now - cache[key].lastSet > ttl) {
            delete cache[key];
        }
    }
};
//# sourceMappingURL=memoize.js.map