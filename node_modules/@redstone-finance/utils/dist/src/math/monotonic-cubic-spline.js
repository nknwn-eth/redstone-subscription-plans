"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.monotoneCubicInterpolation = exports.CubicInterpolation = void 0;
class CubicInterpolation {
    xs;
    ys;
    firstSlope;
    lastSlope;
    fun;
    constructor(xs, ys, firstSlope, lastSlope, fun) {
        this.xs = xs;
        this.ys = ys;
        this.firstSlope = firstSlope;
        this.lastSlope = lastSlope;
        this.fun = fun;
    }
    forX(x) {
        if (x < this.xs[0]) {
            return this.ys[0] - this.firstSlope * (this.xs[0] - x);
        }
        else if (x > this.xs[this.xs.length - 1]) {
            return (this.ys[this.ys.length - 1] +
                this.lastSlope * (x - this.xs[this.xs.length - 1]));
        }
        else {
            return this.fun(x);
        }
    }
    forY(y, precision) {
        if (y < this.ys[0]) {
            return this.xs[0] - (this.ys[0] - y) / this.firstSlope;
        }
        else if (y > this.ys[this.ys.length - 1]) {
            return (this.xs[this.xs.length - 1] +
                (y - this.ys[this.ys.length - 1]) / this.lastSlope);
        }
        else {
            const i = findIntervalIndex(y, this.ys);
            if (y === this.ys[i]) {
                return this.xs[i];
            }
            let lowX = this.xs[i];
            let highX = this.xs[i + 1];
            let tries = 50;
            while (lowX <= highX && tries > 0) {
                const midX = (lowX + highX) / 2;
                if (Math.abs(highX - lowX) < precision) {
                    return midX;
                }
                const midY = this.forX(midX);
                if (Math.abs(midY - y) < precision) {
                    return midX;
                }
                if (midY < y) {
                    lowX = midX;
                }
                else {
                    highX = midX;
                }
                tries--;
            }
            throw new Error(`X was not found for Y = ${y.toString()}`);
        }
    }
    getXs() {
        return Object.freeze([...this.xs]);
    }
    getYs() {
        return Object.freeze([...this.ys]);
    }
}
exports.CubicInterpolation = CubicInterpolation;
const monotoneCubicInterpolation = (xs, ys) => {
    const { fun, firstSlope, lastSlope, sortedXs, sortedYs } = createInterpolant(xs, ys);
    return new CubicInterpolation(sortedXs, sortedYs, firstSlope, lastSlope, fun);
};
exports.monotoneCubicInterpolation = monotoneCubicInterpolation;
const createInterpolant = (xs, ys) => {
    if (xs.length != ys.length) {
        throw new Error("The number of xs and ys should be equal");
    }
    if (xs.length === 0) {
        throw new Error("Empty array of xs");
    }
    if (xs.length === 1) {
        throw new Error("Interpolation cannot be performed for a single point");
    }
    const [sortedXs, sortedYs] = sortPoints(xs, ys);
    if (!isMonotonic(sortedYs, false)) {
        throw new Error("The given points are not monotonic");
    }
    if (!isMonotonic(sortedXs, true)) {
        throw new Error("The xs array cannot have duplicates");
    }
    const dxs = [];
    const ms = [];
    for (let i = 0; i < sortedXs.length - 1; i++) {
        const dx = sortedXs[i + 1] - sortedXs[i];
        const dy = sortedYs[i + 1] - sortedYs[i];
        dxs[i] = dx;
        ms[i] = dy / dx;
    }
    const c1s = [ms[0]];
    for (let i = 0; i < dxs.length - 1; i++) {
        const m = ms[i], mNext = ms[i + 1];
        if (m * mNext <= 0) {
            c1s.push(0);
        }
        else {
            const dx = dxs[i], dxNext = dxs[i + 1], common = dx + dxNext;
            c1s.push((3 * common) / ((common + dxNext) / m + (common + dx) / mNext));
        }
    }
    c1s.push(ms[ms.length - 1]);
    const c2s = [], c3s = [];
    for (let i = 0; i < c1s.length - 1; i++) {
        const c1 = c1s[i], m = ms[i], invDx = 1 / dxs[i], common = c1 + c1s[i + 1] - 2 * m;
        c2s.push((m - c1 - common) * invDx);
        c3s.push(common * invDx * invDx);
    }
    return {
        fun: createInterpolantFunction(sortedXs, sortedYs, c1s, c2s, c3s),
        firstSlope: ms[0],
        lastSlope: ms[ms.length - 1],
        sortedXs,
        sortedYs,
    };
};
const sortPoints = (xs, ys) => {
    const indexes = [...Array(xs.length).keys()];
    indexes.sort((a, b) => {
        return xs[a] - xs[b];
    });
    const sortedXs = [];
    const sortedYs = [];
    for (let i = 0; i < xs.length; i++) {
        sortedXs[i] = xs[indexes[i]];
        sortedYs[i] = ys[indexes[i]];
    }
    return [sortedXs, sortedYs];
};
const isMonotonic = (seq, strict) => {
    if (seq.length < 2) {
        return true;
    }
    let direction = "undefined";
    let previous = seq[0];
    for (let i = 1; i < seq.length; i++) {
        const current = seq[i];
        if (current > previous) {
            if (direction === "decreasing") {
                return false;
            }
            direction = "increasing";
        }
        else if (current < previous) {
            if (direction === "increasing") {
                return false;
            }
            direction = "decreasing";
        }
        else if (strict) {
            return false;
        }
        previous = current;
    }
    return true;
};
const createInterpolantFunction = (xs, ys, c1s, c2s, c3s) => (x) => {
    if (x < xs[0] || x > xs[xs.length - 1]) {
        throw new Error(`The function only handles arguments in the range [${xs[0].toString()},${xs[xs.length - 1].toString()}]`);
    }
    const i = findIntervalIndex(x, xs);
    if (x === xs[i]) {
        return ys[i];
    }
    const diff = x - xs[i];
    return ys[i] + diff * (c1s[i] + diff * (c2s[i] + diff * c3s[i]));
};
const findIntervalIndex = (point, points) => {
    for (let i = 0; i < points.length - 1; i++) {
        if (points[i] <= point && point < points[i + 1]) {
            return i;
        }
    }
    if (point === points[points.length - 1]) {
        return points.length - 1;
    }
    throw new Error(`The point (${point}) is outside the point list [${points.join(",")}]`);
};
//# sourceMappingURL=monotonic-cubic-spline.js.map