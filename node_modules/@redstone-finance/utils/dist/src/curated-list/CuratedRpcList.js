"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CuratedRpcList = void 0;
const zod_1 = require("zod");
const common_1 = require("../common");
const logger_1 = require("../logger");
const math_1 = require("../math");
const CuratedRpcListConfigSchema = zod_1.z.object({
    resetQuarantineInterval: zod_1.z.number().default(() => (0, common_1.getFromEnv)("RPC_CURATED_LIST_RESET_QUARANTINE_INTERVAL", zod_1.z.number().default(60_000))),
    evaluationInterval: zod_1.z.number().default(() => (0, common_1.getFromEnv)("RPC_CURATED_LIST_EVALUATION_INTERVAL", zod_1.z.number().default(30_000))),
    maxErrorRate: zod_1.z
        .number()
        .min(0)
        .max(1)
        .default(() => (0, common_1.getFromEnv)("RPC_CURATED_LIST_MAX_ERROR_RATE", zod_1.z.number().default(0.15))),
    extendedLogs: zod_1.z
        .boolean()
        .default(() => (0, common_1.getFromEnv)("RPC_CURATED_LIST_EXTENDED_LOGS", zod_1.z.boolean().default(false))),
    rpcIdentifiers: zod_1.z.string().array().min(1),
    minimalProvidersCount: zod_1.z.number(),
});
class CuratedRpcList {
    config;
    state = {};
    logger;
    freeFromQuarantineTimer;
    evaluationTimer;
    constructor(config, networkId) {
        this.config = CuratedRpcListConfigSchema.parse(config);
        (0, common_1.assert)(this.config.minimalProvidersCount <= this.config.rpcIdentifiers.length, `A minimalProvidersCount can't be bigger than supplied rpcs list length`);
        this.logger = (0, logger_1.loggerFactory)(`curated-rpc-list-${networkId}`);
        for (const rpc of config.rpcIdentifiers) {
            (0, common_1.assert)(!this.state[rpc], `You have passed duplicated rpc identifier=${rpc} to curated rpc list`);
            this.state[rpc] = {
                callsCount: 0,
                errorsCount: 0,
                inQuarantine: false,
                quarantineCounter: 0,
            };
        }
    }
    updateFreeFromQuarantineTimer() {
        if (this.getProvidersInQuarantine().length === 0) {
            clearInterval(this.freeFromQuarantineTimer);
            this.freeFromQuarantineTimer = undefined;
            return;
        }
        this.freeFromQuarantineTimer ??= setInterval(() => this.freeOneRpcFromQuarantine(), this.config.resetQuarantineInterval);
    }
    updateEvaluationTimer() {
        if (this.getCalledProviders().length === 0) {
            clearInterval(this.evaluationTimer);
            this.evaluationTimer = undefined;
            return;
        }
        this.evaluationTimer ??= setInterval(() => {
            this.config.rpcIdentifiers.map((rpc) => this.evaluateRpcScore(rpc));
        }, this.config.evaluationInterval);
    }
    scoreRpc(rpc, score) {
        this.state[rpc].callsCount += 1;
        this.state[rpc].errorsCount += score.error ? 1 : 0;
        this.updateEvaluationTimer();
    }
    evaluateRpcScore(rpc) {
        const stats = this.state[rpc];
        const errorRate = stats.errorsCount / stats.callsCount;
        if (errorRate > this.config.maxErrorRate) {
            stats.inQuarantine = true;
            stats.quarantineCounter += 1;
            const index = this.config.rpcIdentifiers.indexOf(rpc);
            (this.config.extendedLogs ? this.logger.info : this.logger.debug)(`Sending provider with identifier=${rpc} to quarantine; errorRate=${errorRate.toFixed(2)}; index: ${index}`, { errorRate, rpc, index, quarantined: true });
            this.updateFreeFromQuarantineTimer();
        }
        stats.callsCount = 0;
        stats.errorsCount = 0;
        this.updateEvaluationTimer();
    }
    getBestProviders() {
        const healthyProviders = Object.entries(this.state)
            .filter(([_, { inQuarantine }]) => !inQuarantine)
            .map(([rpc]) => rpc);
        if (healthyProviders.length < this.config.minimalProvidersCount) {
            this.logger.warn(`Not enough healthy providers, have to release one from quarantine`);
            this.freeOneRpcFromQuarantine();
            return this.getBestProviders();
        }
        return healthyProviders;
    }
    freeOneRpcFromQuarantine() {
        const providersInQuarantine = this.getProvidersInQuarantine();
        const weights = providersInQuarantine.map((v) => 1 / v[1].quarantineCounter);
        const index = (0, math_1.weightedRandom)(weights);
        if (index >= 0) {
            providersInQuarantine[index][1].inQuarantine = false;
            const rpc = providersInQuarantine[index][0];
            const rpcIndex = this.config.rpcIdentifiers.indexOf(rpc);
            (this.config.extendedLogs ? this.logger.info : this.logger.debug)(`Releasing provider identifier=${rpc} from quarantine`, {
                rpc,
                index: rpcIndex,
                quarantined: false,
            });
            this.updateFreeFromQuarantineTimer();
        }
    }
    getProvidersInQuarantine() {
        return Object.entries(this.state).filter(([_, { inQuarantine }]) => inQuarantine);
    }
    getCalledProviders() {
        return Object.entries(this.state).filter(([_, { callsCount }]) => callsCount > 0);
    }
}
exports.CuratedRpcList = CuratedRpcList;
//# sourceMappingURL=CuratedRpcList.js.map