"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiExecutorFactory = void 0;
const __1 = require("..");
const common_1 = require("../common");
const logger_1 = require("../logger");
const AgreementExecutor_1 = require("./AgreementExecutor");
const ConsensusExecutor_1 = require("./ConsensusExecutor");
const Executor_1 = require("./Executor");
const FallbackExecutor_1 = require("./FallbackExecutor");
const MultiAgreementExecutor_1 = require("./MultiAgreementExecutor");
const RaceExecutor_1 = require("./RaceExecutor");
const config_1 = require("./config");
class MultiExecutorFactory {
    instances;
    methodConfig;
    config;
    logger = (0, logger_1.loggerFactory)("multi-executor-proxy");
    constructor(instances, methodConfig, config) {
        this.instances = instances;
        this.methodConfig = methodConfig;
        this.config = config;
    }
    getMethodMode(methodName) {
        const mode = this.methodConfig[methodName];
        if (mode instanceof Executor_1.Executor) {
            return mode;
        }
        if (typeof mode === "string") {
            return mode;
        }
        if (mode === undefined) {
            return this.config.defaultMode;
        }
        throw new Error(`Unexpected NestedMethodConfig for function ${methodName.toString()}`);
    }
    getExecutor(mode) {
        if (mode instanceof Executor_1.Executor) {
            return mode;
        }
        switch (mode) {
            case config_1.ExecutionMode.RACE:
                return new RaceExecutor_1.RaceExecutor();
            case config_1.ExecutionMode.FALLBACK:
                return new FallbackExecutor_1.FallbackExecutor(this.config.singleExecutionTimeoutMs);
            case config_1.ExecutionMode.CONSENSUS_MEDIAN:
                return new ConsensusExecutor_1.MedianConsensusExecutor(this.config.consensusQuorumRatio, this.config.singleExecutionTimeoutMs);
            case config_1.ExecutionMode.CONSENSUS_ALL_EQUAL:
                return new ConsensusExecutor_1.AllEqualConsensusExecutor(this.config.consensusQuorumRatio, this.config.singleExecutionTimeoutMs);
            case config_1.ExecutionMode.AGREEMENT:
                return new AgreementExecutor_1.AgreementExecutor(this.config.agreementQuorumNumber, this.config.singleExecutionTimeoutMs);
            case config_1.ExecutionMode.MULTI_AGREEMENT:
                return new MultiAgreementExecutor_1.MultiAgreementExecutor(this.config.agreementQuorumNumber, this.config.singleExecutionTimeoutMs, this.config.multiAgreementShouldResolveUnagreedToUndefined);
            default:
                return (0, common_1.throwUnsupportedParamError)(mode);
        }
    }
    createProxy() {
        const that = this;
        Object.assign(this.instances[0], {
            __instances: this.instances,
            __config: this.config,
        });
        return new Proxy(this.instances[0], {
            get(target, prop) {
                const key = prop;
                const method = target[key];
                if (Object(method) !== method ||
                    ["__instances", "__config"].includes(key)) {
                    return method;
                }
                if (typeof method !== "function") {
                    return __1.MultiExecutor.create(that.instances.map((instance) => instance[key]), that.methodConfig[key] ?? {}, that.config);
                }
                if (method.constructor.name === "AsyncFunction" ||
                    method.toString().includes("Promise")) {
                    return async function (...args) {
                        const functions = that.instances.map((instance, index) => MultiExecutorFactory.makeFnBox(method.name, that.config, index, instance, key, args));
                        return await that.performExecuting(key, functions);
                    };
                }
                return function (...args) {
                    return target[key].call(target, ...args);
                };
            },
        });
    }
    static makeFnBox(name, config, index, instance, key, args) {
        return {
            name,
            description: config.descriptions?.[index],
            index,
            delegate: config.delegate,
            fn: () => Promise.resolve(instance[key].call(instance, ...args)),
        };
    }
    async performExecuting(key, functions) {
        const mode = this.getMethodMode(key);
        this.logger.debug(`[${(0, common_1.stringify)(key)}] Executing ${functions.length} promise${(0, common_1.getS)(functions.length)}` +
            ` with ${typeof mode === "string" ? mode : typeof mode}` +
            (this.config.allExecutionsTimeoutMs
                ? ` and totalExecutionTimeout: ${this.config.allExecutionsTimeoutMs} [ms]`
                : ""));
        const result = this.getExecutor(mode).execute(functions);
        const value = await (0, common_1.timeoutOrResult)(result, this.config.allExecutionsTimeoutMs);
        this.logger.debug(`[${(0, common_1.stringify)(key)}] Returning ${(0, common_1.stringify)(value)}`);
        return value;
    }
}
exports.MultiExecutorFactory = MultiExecutorFactory;
//# sourceMappingURL=MultiExecutorFactory.js.map