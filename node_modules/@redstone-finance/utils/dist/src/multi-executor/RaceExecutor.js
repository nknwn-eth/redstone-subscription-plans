"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RaceExecutor = void 0;
const lodash_1 = __importDefault(require("lodash"));
const common_1 = require("../common");
const Executor_1 = require("./Executor");
class RaceExecutor extends Executor_1.Executor {
    shouldFailWhenFastestFails;
    constructor(shouldFailWhenFastestFails = false) {
        super();
        this.shouldFailWhenFastestFails = shouldFailWhenFastestFails;
    }
    async execute(functions) {
        const date = Date.now();
        const indexedPromises = Executor_1.Executor.getPromises(functions).map((promise, index) => promise.then((result) => ({ index, result })));
        const winner = await (this.shouldFailWhenFastestFails
            ? Promise.race(indexedPromises)
            : Promise.any(indexedPromises));
        this.logger.info(`Promise #${winner.index} won in ${Date.now() - date} [ms]`);
        void Promise.allSettled(indexedPromises).then((results) => {
            const failed = results
                .map((result, index) => ({ ...result, index }))
                .filter((r) => r.status === "rejected");
            if (failed.length > 0) {
                this.logger.warn(`Race completed successfully, but ${failed.length} other promise${(0, common_1.getS)(failed.length)} failed:`, lodash_1.default.map(failed, (item) => `Promise #${item.index} failed: ${item.reason}`));
            }
        });
        return winner.result;
    }
}
exports.RaceExecutor = RaceExecutor;
//# sourceMappingURL=RaceExecutor.js.map