"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParallelExecutor = void 0;
const lodash_1 = __importDefault(require("lodash"));
const common_1 = require("../common");
const Executor_1 = require("./Executor");
class ParallelExecutor extends Executor_1.Executor {
    timeoutMs;
    constructor(timeoutMs) {
        super();
        this.timeoutMs = timeoutMs;
    }
    static getModes(results) {
        if (results.length === 0) {
            return undefined;
        }
        const uniqueElements = lodash_1.default.uniqWith(results, (left, right) => lodash_1.default.isEqual(left, right));
        const counts = uniqueElements.map((item) => ({
            item,
            count: results.filter((d) => lodash_1.default.isEqual(d, item)).length,
        }));
        const maxCount = lodash_1.default.maxBy(counts, "count")?.count ?? 0;
        return counts.filter((c) => c.count === maxCount);
    }
    async execute(functions) {
        const promises = Executor_1.Executor.getPromises(functions, this.timeoutMs);
        const successfulResults = [];
        const errorResults = [];
        let didFinish = false;
        return await new Promise((resolve, reject) => {
            promises.forEach((result) => {
                result
                    .then((result) => {
                    successfulResults.push(result);
                })
                    .catch((error) => {
                    errorResults.push(error);
                })
                    .finally(() => {
                    didFinish ||= this.handleResults(successfulResults, errorResults, promises.length, resolve, reject);
                });
            });
        });
    }
    handleResults(successfulResults, errorResults, totalLength, resolve, reject) {
        try {
            const isEnough = this.verifySettlements(successfulResults, errorResults, totalLength);
            if (isEnough) {
                const value = this.aggregate(successfulResults);
                this.logger.debug(`Resolving with ${(0, common_1.stringify)(value)}`);
                resolve(value);
            }
            return isEnough;
        }
        catch (error) {
            reject(error);
            return true;
        }
    }
}
exports.ParallelExecutor = ParallelExecutor;
//# sourceMappingURL=ParallelExecutor.js.map