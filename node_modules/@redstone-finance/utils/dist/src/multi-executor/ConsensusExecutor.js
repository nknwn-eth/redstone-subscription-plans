"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MedianConsensusExecutor = exports.AllEqualConsensusExecutor = exports.ConsensusExecutor = void 0;
const lodash_1 = __importDefault(require("lodash"));
const common_1 = require("../common");
const math_1 = require("../math");
const ParallelExecutor_1 = require("./ParallelExecutor");
class ConsensusExecutor extends ParallelExecutor_1.ParallelExecutor {
    quorumRatio;
    constructor(quorumRatio, timeoutMs) {
        super(timeoutMs);
        this.quorumRatio = quorumRatio;
    }
    verifySettlements(successfulResults, errorResults, totalLength) {
        if (successfulResults.length + errorResults.length < totalLength) {
            this.logger.debug(`Returning, still doesn't have all of ${totalLength} results: ${successfulResults.length} successes + ${errorResults.length} errors`);
            return false;
        }
        const quorum = this.getQuorum(totalLength);
        if (successfulResults.length >= quorum) {
            return true;
        }
        const failedCount = errorResults.length;
        throw new Error(`Consensus failed: got ${successfulResults.length} successful result${(0, common_1.getS)(successfulResults.length)}, ` +
            `needed at least ${quorum}; ${(0, common_1.stringifyError)(new AggregateError(errorResults, `${failedCount} fail${(0, common_1.getS)(failedCount)}`))})`);
    }
    getQuorum(totalLength) {
        return totalLength <= 2 ? 1 : Math.ceil(totalLength * this.quorumRatio);
    }
}
exports.ConsensusExecutor = ConsensusExecutor;
class AllEqualConsensusExecutor extends ConsensusExecutor {
    aggregate(results) {
        const unique = lodash_1.default.uniqWith(results, (left, right) => lodash_1.default.isEqual(left, right));
        if (unique.length > 1) {
            throw new Error(`Results are not equal. Found ${unique.length} different results ${JSON.stringify(unique)}`);
        }
        return unique[0];
    }
}
exports.AllEqualConsensusExecutor = AllEqualConsensusExecutor;
class MedianConsensusExecutor extends ConsensusExecutor {
    aggregate(results) {
        return MedianConsensusExecutor.getMedian(results);
    }
    static getMedian(results) {
        const hasOnlyNumbers = results.every((n) => typeof n === "number");
        if (hasOnlyNumbers) {
            return (0, math_1.getMedian)(results);
        }
        return (0, math_1.getMedianOfBigNumbers)(results);
    }
}
exports.MedianConsensusExecutor = MedianConsensusExecutor;
//# sourceMappingURL=ConsensusExecutor.js.map