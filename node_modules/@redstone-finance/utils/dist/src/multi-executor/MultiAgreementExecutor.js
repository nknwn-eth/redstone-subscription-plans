"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiAgreementExecutor = void 0;
const lodash_1 = __importDefault(require("lodash"));
const common_1 = require("../common");
const AgreementExecutor_1 = require("./AgreementExecutor");
class MultiAgreementExecutor extends AgreementExecutor_1.AgreementExecutor {
    agreementExecutor;
    constructor(quorumNumber, timeoutMs, shouldResolveUnagreedToUndefined = false) {
        super(quorumNumber, timeoutMs, shouldResolveUnagreedToUndefined);
        this.agreementExecutor = new AgreementExecutor_1.AgreementExecutor(quorumNumber, timeoutMs, shouldResolveUnagreedToUndefined);
    }
    aggregate(results) {
        return lodash_1.default.zip(...results).map((result) => this.agreementExecutor.aggregate(result));
    }
    verifySettlements(successfulResults, errorResults, totalLength) {
        const quorum = this.getQuorum(totalLength);
        if (successfulResults.length < quorum) {
            if (successfulResults.length + errorResults.length === totalLength) {
                throw new Error(`MultiAgreement failed: got ${successfulResults.length} successful result${(0, common_1.getS)(successfulResults.length)}, ` +
                    `needed at least ${quorum}`);
            }
            this.logger.debug(`Returning, still doesn't have enough of ${quorum} results: ${successfulResults.length} successes + ${errorResults.length} errors`);
            return false;
        }
        const partialSettlements = lodash_1.default.zip(...successfulResults).map((result) => {
            return this.agreementExecutor.verifySettlements(result, errorResults, totalLength);
        });
        return !partialSettlements.includes(false);
    }
}
exports.MultiAgreementExecutor = MultiAgreementExecutor;
//# sourceMappingURL=MultiAgreementExecutor.js.map