"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsNativeSafeNumber = exports.JsNativeSafeNumberConfig = exports.NumberValidationResult = void 0;
const logger_1 = require("../logger");
var NumberValidationResult;
(function (NumberValidationResult) {
    NumberValidationResult[NumberValidationResult["isOk"] = 0] = "isOk";
    NumberValidationResult[NumberValidationResult["isNaN"] = 1] = "isNaN";
    NumberValidationResult[NumberValidationResult["isNotFinite"] = 2] = "isNotFinite";
    NumberValidationResult[NumberValidationResult["isOverflow"] = 3] = "isOverflow";
    NumberValidationResult[NumberValidationResult["isUnderflow"] = 4] = "isUnderflow";
})(NumberValidationResult || (exports.NumberValidationResult = NumberValidationResult = {}));
const logger = (0, logger_1.loggerFactory)("JsNativeSafeNumber");
exports.JsNativeSafeNumberConfig = {
    MAX_NUMBER: Number.MAX_SAFE_INTEGER,
    MIN_NUMBER: 1e-14,
    MAX_DECIMALS: 14,
    DIGIT_REGEXP: /^[-+]?(\d+(\.\d{1,63})?|\.\d{1,63})([eE][-+]?\d+)?$/,
    ON_NUMBER_VALIDATION_ERROR: {
        [NumberValidationResult.isNaN]: (msg) => {
            throw new Error(msg);
        },
        [NumberValidationResult.isNotFinite]: (msg) => {
            throw new Error(msg);
        },
        [NumberValidationResult.isOverflow]: logger.error.bind(logger),
        [NumberValidationResult.isUnderflow]: () => { },
    },
    EPSILON: 1e-14,
};
class JsNativeSafeNumber {
    static from(numberLike) {
        if (numberLike instanceof JsNativeSafeNumber) {
            return new JsNativeSafeNumber(numberLike.unsafeToNumber());
        }
        else if (typeof numberLike === "number" ||
            typeof numberLike === "string") {
            return new JsNativeSafeNumber(parseToSafeNumber(numberLike));
        }
        else {
            throw new Error(`Invalid number format: Tried to create JsNativeSafeNumber from ${JSON.stringify(numberLike)}`);
        }
    }
    _value;
    constructor(value) {
        this._value = value;
    }
    decimals() {
        return exports.JsNativeSafeNumberConfig.MAX_DECIMALS;
    }
    toString() {
        return this._value.toString();
    }
    isSafeNumber() {
        return true;
    }
    abs() {
        const result = Math.abs(this._value);
        return this.produceNewSafeNumber(result);
    }
    log2() {
        const result = Math.log2(this._value);
        return this.produceNewSafeNumber(result);
    }
    mod(divisor) {
        const result = this._value % JsNativeSafeNumber.from(divisor).unsafeToNumber();
        return this.produceNewSafeNumber(result);
    }
    round() {
        const result = Math.round(this._value);
        return new JsNativeSafeNumber(result);
    }
    add(numberLike) {
        const result = this._value + JsNativeSafeNumber.from(numberLike).unsafeToNumber();
        return this.produceNewSafeNumber(result);
    }
    sub(numberLike) {
        const result = this._value - JsNativeSafeNumber.from(numberLike).unsafeToNumber();
        return this.produceNewSafeNumber(result);
    }
    div(numberLike) {
        const result = this._value / JsNativeSafeNumber.from(numberLike).unsafeToNumber();
        return this.produceNewSafeNumber(result);
    }
    mul(numberLike) {
        const result = this._value * JsNativeSafeNumber.from(numberLike).unsafeToNumber();
        return this.produceNewSafeNumber(result);
    }
    assertNonNegative() {
        if (this._value < 0) {
            throw new Error("Assert non negative failed");
        }
    }
    assertPositive() {
        if (this._value <= 0) {
            throw new Error("Assert positive failed");
        }
    }
    unsafeToNumber() {
        return this._value;
    }
    eq(numberArg) {
        const number = JsNativeSafeNumber.from(numberArg);
        return (Math.abs(number.unsafeToNumber() - this._value) <
            exports.JsNativeSafeNumberConfig.EPSILON);
    }
    lt(numberArg) {
        return this._value < JsNativeSafeNumber.from(numberArg).unsafeToNumber();
    }
    lte(numberArg) {
        return this.lt(numberArg) || this.eq(numberArg);
    }
    gt(numberArg) {
        return this._value > JsNativeSafeNumber.from(numberArg).unsafeToNumber();
    }
    gte(numberArg) {
        return this.gt(numberArg) || this.eq(numberArg);
    }
    toJSON() {
        return this.unsafeToNumber();
    }
    produceNewSafeNumber(result) {
        const newNumber = new JsNativeSafeNumber(result);
        newNumber.assertValidAndRound();
        return newNumber;
    }
    assertValidAndRound() {
        const { result: validationResult, message } = validateNumber(this._value);
        if (validationResult !== NumberValidationResult.isOk) {
            exports.JsNativeSafeNumberConfig.ON_NUMBER_VALIDATION_ERROR[validationResult](message);
        }
        this._value = Number(this._value.toFixed(exports.JsNativeSafeNumberConfig.MAX_DECIMALS));
    }
}
exports.JsNativeSafeNumber = JsNativeSafeNumber;
const validateNumber = (number) => {
    if (Number.isNaN(number)) {
        return {
            result: NumberValidationResult.isNaN,
            message: "Invalid number format: number is NaN",
        };
    }
    else if (!Number.isFinite(number)) {
        return {
            result: NumberValidationResult.isNotFinite,
            message: "Invalid number format: number is not finite",
        };
    }
    if (Math.abs(number) > exports.JsNativeSafeNumberConfig.MAX_NUMBER) {
        return {
            result: NumberValidationResult.isOverflow,
            message: `Invalid number format: Number is bigger than max number acceptable by REDSTONE (${number})`,
        };
    }
    if (Math.abs(number) < exports.JsNativeSafeNumberConfig.MIN_NUMBER && number !== 0) {
        return {
            result: NumberValidationResult.isUnderflow,
            message: `Invalid number format: Number is smaller than min number acceptable by REDSTONE (${number})`,
        };
    }
    return { result: NumberValidationResult.isOk, message: "" };
};
const parseToSafeNumber = (value) => {
    let number;
    if (typeof value === "string") {
        if (!exports.JsNativeSafeNumberConfig.DIGIT_REGEXP.test(value)) {
            throw new Error(`Invalid number format: ${value}, not matching regexp: ${exports.JsNativeSafeNumberConfig.DIGIT_REGEXP}`);
        }
        number = Number(value);
    }
    else if (typeof value === "number") {
        number = Number(value);
    }
    else {
        throw new Error(`Invalid number format, expected: string or number`);
    }
    const { result: validationResult, message } = validateNumber(number);
    if (validationResult !== NumberValidationResult.isOk) {
        exports.JsNativeSafeNumberConfig.ON_NUMBER_VALIDATION_ERROR[validationResult](message);
    }
    return number;
};
//# sourceMappingURL=JsNativeSafeNumber.js.map