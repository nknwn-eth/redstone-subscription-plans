"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseWrapper = void 0;
const protocol_1 = require("@redstone-finance/protocol");
const ethers_1 = require("ethers");
const add_contract_wait_1 = require("../helpers/add-contract-wait");
class BaseWrapper {
    contract;
    explicitMetadataTimestamp;
    async getBytesDataForAppending() {
        const shouldBeMultipleOf32 = false;
        return await this.prepareRedstonePayload(shouldBeMultipleOf32);
    }
    async getRedstonePayloadForManualUsage(contract) {
        this.setContractForFetchingDefaultParams(contract);
        const shouldBeMultipleOf32 = true;
        const payloadWithoutZeroExPrefix = await this.prepareRedstonePayload(shouldBeMultipleOf32);
        return "0x" + payloadWithoutZeroExPrefix;
    }
    async prepareRedstonePayload(shouldBeMultipleOf32) {
        const signedDataPackages = await this.getDataPackagesForPayload();
        let unsignedMetadata = this.getUnsignedMetadata();
        const originalPayload = protocol_1.RedstonePayload.prepare(signedDataPackages, unsignedMetadata);
        if (!shouldBeMultipleOf32) {
            return originalPayload;
        }
        const originalPayloadLength = originalPayload.length / 2;
        const bytesToAdd = 32 - (originalPayloadLength % 32);
        unsignedMetadata += "_".repeat(bytesToAdd);
        return protocol_1.RedstonePayload.prepare(signedDataPackages, unsignedMetadata);
    }
    setContractForFetchingDefaultParams(contract) {
        this.contract = contract;
    }
    overwriteEthersContract(contract) {
        this.setContractForFetchingDefaultParams(contract);
        const contractPrototype = Object.getPrototypeOf(contract);
        const wrappedContract = Object.assign(Object.create(contractPrototype), contract, { populateTransaction: {} });
        const functionNames = Object.keys(contract.functions);
        functionNames.forEach((functionName) => {
            if (!functionName.includes("(")) {
                this.overwritePopulateTransaction({
                    wrappedContract,
                    contract,
                    functionName,
                });
                this.overwriteFunction({ wrappedContract, contract, functionName });
            }
        });
        return wrappedContract;
    }
    overwritePopulateTransaction({ wrappedContract, contract, functionName, }) {
        wrappedContract.populateTransaction[functionName] = async (...args) => {
            const originalTx = await contract.populateTransaction[functionName](...args);
            const dataToAppend = await this.getBytesDataForAppending();
            originalTx.data += dataToAppend;
            return originalTx;
        };
    }
    overwriteFunction({ wrappedContract, contract, functionName, }) {
        const functionFragment = contract.interface.getFunction(functionName);
        const isCall = functionFragment.constant;
        const isDryRun = functionName.endsWith("DryRun");
        wrappedContract[functionName] = async (...args) => {
            const blockTag = BaseWrapper.handleContractOverrides(args, functionFragment);
            const tx = await wrappedContract.populateTransaction[functionName](...args);
            if (isCall || isDryRun) {
                const shouldUseSigner = ethers_1.Signer.isSigner(contract.signer);
                const result = await contract[shouldUseSigner ? "signer" : "provider"].call(tx, blockTag);
                const decoded = contract.interface.decodeFunctionResult(functionName, result);
                return decoded.length == 1 ? decoded[0] : decoded;
            }
            else {
                const sentTx = await contract.signer.sendTransaction(tx);
                (0, add_contract_wait_1.addContractWait)(contract, sentTx);
                return sentTx;
            }
        };
    }
    static handleContractOverrides(args, functionFragment) {
        let blockTag = undefined;
        if (args.length === functionFragment.inputs.length + 1 &&
            typeof args[args.length - 1] === "object") {
            const overrides = { ...args.pop() };
            blockTag = overrides.blockTag;
            delete overrides.blockTag;
            args.push(overrides);
        }
        return blockTag;
    }
    setMetadataTimestamp(timestamp) {
        this.explicitMetadataTimestamp = timestamp;
    }
    getMetadataTimestamp() {
        return this.explicitMetadataTimestamp ?? Date.now();
    }
}
exports.BaseWrapper = BaseWrapper;
//# sourceMappingURL=BaseWrapper.js.map