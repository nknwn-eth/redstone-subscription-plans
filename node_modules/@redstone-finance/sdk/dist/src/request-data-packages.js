"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractSignedDataPackagesForFeedId = exports.checkAndGetSameTimestamp = exports.getDataPackagesTimestamp = exports.getResponseTimestamp = exports.requestDataPackages = exports.calculateHistoricalPackagesTimestamp = exports.SignedDataPackageSchema = exports.DataFeedPackageError = exports.DataFeedPackageErrorType = exports.HISTORICAL_DATA_PACKAGES_DENOMINATOR_MS = void 0;
exports.convertToHistoricalDataPackagesRequestParams = convertToHistoricalDataPackagesRequestParams;
const protocol_1 = require("@redstone-finance/protocol");
const utils_1 = require("@redstone-finance/utils");
const axios_1 = __importDefault(require("axios"));
const zod_1 = require("zod");
const data_services_urls_1 = require("./data-services-urls");
const pick_closest_to_median_1 = require("./pick-closest-to-median");
const RequestDataPackagesLogger_1 = require("./RequestDataPackagesLogger");
const GET_REQUEST_TIMEOUT = 5_000;
const DEFAULT_WAIT_FOR_ALL_GATEWAYS_TIME = 500;
exports.HISTORICAL_DATA_PACKAGES_DENOMINATOR_MS = 10000;
var DataFeedPackageErrorType;
(function (DataFeedPackageErrorType) {
    DataFeedPackageErrorType["MissingDataFeed"] = "MissingDataFeed";
    DataFeedPackageErrorType["NoDataPackages"] = "NoDataPackages";
    DataFeedPackageErrorType["TooFewSigners"] = "TooFewSigners";
})(DataFeedPackageErrorType || (exports.DataFeedPackageErrorType = DataFeedPackageErrorType = {}));
class DataFeedPackageError extends Error {
    dataFeedId;
    errorType;
    constructor(message, dataFeedId, errorType) {
        super(message);
        this.dataFeedId = dataFeedId;
        this.errorType = errorType;
    }
}
exports.DataFeedPackageError = DataFeedPackageError;
exports.SignedDataPackageSchema = zod_1.z.object({
    dataPoints: zod_1.z
        .array(zod_1.z
        .object({
        dataFeedId: zod_1.z.string(),
        value: zod_1.z.number(),
        decimals: zod_1.z.number().optional(),
    })
        .or(zod_1.z.object({
        dataFeedId: zod_1.z.string(),
        value: zod_1.z.string(),
        decimals: zod_1.z.number().optional(),
    })))
        .min(1),
    timestampMilliseconds: zod_1.z.number(),
    signature: zod_1.z.string(),
    signerAddress: zod_1.z.string().optional(),
    dataPackageId: zod_1.z.string(),
});
const GwResponseSchema = zod_1.z.record(zod_1.z.string(), zod_1.z.array(exports.SignedDataPackageSchema));
const calculateHistoricalPackagesTimestamp = (deviationCheckOffsetInMilliseconds, baseTimestamp = Date.now(), denominator = exports.HISTORICAL_DATA_PACKAGES_DENOMINATOR_MS) => {
    if (deviationCheckOffsetInMilliseconds > 0) {
        return (Math.floor((baseTimestamp - deviationCheckOffsetInMilliseconds) / denominator) * denominator);
    }
    return undefined;
};
exports.calculateHistoricalPackagesTimestamp = calculateHistoricalPackagesTimestamp;
const requestDataPackages = async (reqParams) => {
    if (!reqParams.returnAllPackages && !reqParams.dataPackagesIds.length) {
        throw new Error("Please provide at least one dataFeed");
    }
    try {
        const urls = getUrlsForDataServiceId(reqParams);
        const requestDataPackagesLogger = reqParams.enableEnhancedLogs
            ? new RequestDataPackagesLogger_1.RequestDataPackagesLogger(urls.length, !!reqParams.historicalTimestamp)
            : undefined;
        const promises = prepareDataPackagePromises(reqParams, urls, requestDataPackagesLogger);
        return await getTheMostRecentDataPackages(promises, reqParams.historicalTimestamp
            ? 0
            : reqParams.waitForAllGatewaysTimeMs, requestDataPackagesLogger);
    }
    catch (e) {
        const errMessage = `Request failed: ${JSON.stringify({
            reqParams,
        })}, Original error: ${utils_1.RedstoneCommon.stringifyError(e)}`;
        if (e instanceof AggregateError) {
            e.message = errMessage;
            throw e;
        }
        throw new Error(errMessage);
    }
};
exports.requestDataPackages = requestDataPackages;
const getResponseTimestamp = (response) => Object.values(response).at(0)?.at(0)?.dataPackage.timestampMilliseconds ?? 0;
exports.getResponseTimestamp = getResponseTimestamp;
const getTheMostRecentDataPackages = (promises, waitForAllGatewaysTimeMs = DEFAULT_WAIT_FOR_ALL_GATEWAYS_TIME, requestDataPackagesLogger) => {
    return new Promise((resolve, reject) => {
        const collectedResponses = [];
        const collectedErrors = [];
        let isTimedOut = false;
        let didResolveOrReject = false;
        let timer;
        if (waitForAllGatewaysTimeMs) {
            timer = setTimeout(() => {
                isTimedOut = true;
                checkResults(true);
            }, waitForAllGatewaysTimeMs);
        }
        else {
            isTimedOut = true;
        }
        const checkResults = (timeout = false) => {
            requestDataPackagesLogger?.willCheckState(timeout, didResolveOrReject);
            if (didResolveOrReject) {
                return;
            }
            if (collectedErrors.length === promises.length) {
                requestDataPackagesLogger?.willReject();
                clearTimeout(timer);
                didResolveOrReject = true;
                reject(new AggregateError(collectedErrors));
            }
            else if (collectedResponses.length + collectedErrors.length ===
                promises.length ||
                (isTimedOut && collectedResponses.length !== 0)) {
                const newestPackage = collectedResponses.reduce((a, b) => ((0, exports.getResponseTimestamp)(b) > (0, exports.getResponseTimestamp)(a) ? b : a), {});
                requestDataPackagesLogger?.willResolve(newestPackage);
                clearTimeout(timer);
                didResolveOrReject = true;
                resolve(newestPackage);
            }
        };
        for (let i = 0; i < promises.length; i++) {
            promises[i]
                .then((r) => {
                collectedResponses.push(r);
                requestDataPackagesLogger?.didReceiveResponse(r, i);
            })
                .catch((e) => {
                collectedErrors.push(e);
                requestDataPackagesLogger?.didReceiveError(e, i);
            })
                .finally(checkResults);
        }
    });
};
const prepareDataPackagePromises = (reqParams, urls, requestDataPackagesLogger) => {
    if (!reqParams.authorizedSigners.length) {
        throw new Error("Authorized signers array cannot be empty");
    }
    const pathComponents = [
        "v2",
        "data-packages",
        reqParams.historicalTimestamp ? "historical" : "latest",
        reqParams.dataServiceId,
    ];
    if (reqParams.historicalTimestamp) {
        pathComponents.push(`${reqParams.historicalTimestamp}`);
    }
    if (reqParams.hideMetadata === false) {
        pathComponents.push("show-metadata");
    }
    return urls.map(async (url) => {
        const response = await sendRequestToGateway(url, pathComponents);
        return parseAndValidateDataPackagesResponse(response.data, reqParams, requestDataPackagesLogger);
    });
};
function validateDataPackagesResponse(dataFeedPackages, reqParams, dataFeedId) {
    if (!dataFeedPackages) {
        const message = `Requested data feed id is not included in response: ${dataFeedId}`;
        throw new DataFeedPackageError(message, dataFeedId, DataFeedPackageErrorType.MissingDataFeed);
    }
    dataFeedPackages = dataFeedPackages.filter((dp) => {
        const signer = reqParams.skipSignatureVerification
            ? dp.signerAddress
            : maybeGetSigner(dp);
        return signer ? reqParams.authorizedSigners.includes(signer) : false;
    });
    if (dataFeedPackages.length === 0) {
        const message = `No data packages for the data feed: ${dataFeedId}`;
        throw new DataFeedPackageError(message, dataFeedId, DataFeedPackageErrorType.NoDataPackages);
    }
    else if (dataFeedPackages.length < reqParams.uniqueSignersCount) {
        const message = `Too few data packages with unique signers for the data feed: ${dataFeedId}. ` +
            `Expected: ${reqParams.uniqueSignersCount}. ` +
            `Received: ${dataFeedPackages.length}`;
        throw new DataFeedPackageError(message, dataFeedId, DataFeedPackageErrorType.TooFewSigners);
    }
    const signedDataPackages = dataFeedPackages.map((dp) => protocol_1.SignedDataPackage.fromObj(dp));
    const timestamp = (0, exports.checkAndGetSameTimestamp)(signedDataPackages);
    if (reqParams.maxTimestampDeviationMS) {
        const deviation = Math.abs(Date.now() - timestamp);
        if (deviation > reqParams.maxTimestampDeviationMS) {
            const message = `Timestamp deviation exceeded - timestamp: ${timestamp}, deviation: ${deviation}, max deviation: ${reqParams.maxTimestampDeviationMS}`;
            throw new Error(message);
        }
    }
    return signedDataPackages;
}
const parseAndValidateDataPackagesResponse = (responseData, reqParams, requestDataPackagesLogger) => {
    const parsedResponse = {};
    utils_1.RedstoneCommon.zodAssert(GwResponseSchema, responseData);
    const requestedDataFeedIds = reqParams.returnAllPackages
        ? Object.keys(responseData)
        : reqParams.dataPackagesIds;
    const errors = [];
    for (const dataFeedId of requestedDataFeedIds) {
        try {
            const dataFeedPackagesResponse = responseData[dataFeedId];
            const dataFeedPackages = validateDataPackagesResponse(dataFeedPackagesResponse, reqParams, dataFeedId);
            parsedResponse[dataFeedId] = reqParams.disableMedianSelection
                ? dataFeedPackages
                : (0, pick_closest_to_median_1.pickDataFeedPackagesClosestToMedian)(dataFeedPackages.map((dp) => dp.toObj()), reqParams.uniqueSignersCount);
        }
        catch (e) {
            if (reqParams.ignoreMissingFeed) {
                requestDataPackagesLogger?.feedIsMissing(e.message);
            }
            else if (reqParams.aggregateErrors) {
                errors.push(e);
            }
            else {
                throw e;
            }
        }
    }
    if (errors.length > 0) {
        throw new AggregateError(errors);
    }
    return parsedResponse;
};
const getUrlsForDataServiceId = (reqParams) => {
    return (reqParams.urls ??
        (0, data_services_urls_1.resolveDataServiceUrls)(reqParams.dataServiceId, {
            historical: !!reqParams.historicalTimestamp,
            metadata: reqParams.hideMetadata === false,
        }));
};
function sendRequestToGateway(url, pathComponents) {
    const sanitizedUrl = [url.replace(/\/+$/, "")]
        .concat(pathComponents)
        .join("/");
    return axios_1.default.get(sanitizedUrl, {
        timeout: GET_REQUEST_TIMEOUT,
    });
}
function maybeGetSigner(dp) {
    try {
        return protocol_1.SignedDataPackage.fromObj(dp).recoverSignerAddress();
    }
    catch {
        return undefined;
    }
}
const getDataPackagesTimestamp = (dataPackages, dataFeedId) => {
    const signedDataPackages = (0, exports.extractSignedDataPackagesForFeedId)(dataPackages, dataFeedId);
    return (0, exports.checkAndGetSameTimestamp)(signedDataPackages);
};
exports.getDataPackagesTimestamp = getDataPackagesTimestamp;
const checkAndGetSameTimestamp = (dataPackages) => {
    if (!dataPackages.length) {
        throw new Error("No data packages for unique timestamp calculation");
    }
    const timestamps = dataPackages.map((dp) => dp.dataPackage.timestampMilliseconds);
    if (new Set(timestamps).size !== 1) {
        throw new Error(`Timestamps do not have the same value: ${timestamps.join(", ")}`);
    }
    return timestamps[0];
};
exports.checkAndGetSameTimestamp = checkAndGetSameTimestamp;
const extractSignedDataPackagesForFeedId = (dataPackages, dataFeedId) => {
    if (dataFeedId && dataPackages[dataFeedId]) {
        return dataPackages[dataFeedId];
    }
    const signedDataPackages = Object.values(dataPackages).flatMap((dataPackages) => dataPackages);
    if (!dataFeedId) {
        return signedDataPackages;
    }
    return signedDataPackages.filter((dataPackage) => dataPackage.dataPackage.dataPoints.some((dataPoint) => dataPoint.dataFeedId === dataFeedId));
};
exports.extractSignedDataPackagesForFeedId = extractSignedDataPackagesForFeedId;
function convertToHistoricalDataPackagesRequestParams(requestParams, config, latestDataPackagesTimestamp, baseTimestamp) {
    const { fallbackOffsetInMilliseconds, historicalPackagesGateways } = config;
    if (!fallbackOffsetInMilliseconds ||
        !historicalPackagesGateways ||
        !Array.isArray(historicalPackagesGateways) ||
        !historicalPackagesGateways.length) {
        throw new Error(`Historical packages fetcher for fallback deviation check is not properly configured: ` +
            `offset=${fallbackOffsetInMilliseconds} milliseconds., gateways=${JSON.stringify(historicalPackagesGateways)}, isArray=${Array.isArray(historicalPackagesGateways)} `);
    }
    let historicalTimestamp = (0, exports.calculateHistoricalPackagesTimestamp)(fallbackOffsetInMilliseconds, baseTimestamp);
    if (latestDataPackagesTimestamp &&
        historicalTimestamp >= latestDataPackagesTimestamp) {
        historicalTimestamp = (0, exports.calculateHistoricalPackagesTimestamp)(Math.min(exports.HISTORICAL_DATA_PACKAGES_DENOMINATOR_MS, fallbackOffsetInMilliseconds), latestDataPackagesTimestamp);
    }
    return {
        ...requestParams,
        historicalTimestamp,
        urls: historicalPackagesGateways,
    };
}
//# sourceMappingURL=request-data-packages.js.map