"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractParamsProvider = exports.DEFAULT_COMPONENT_NAME = void 0;
const bytes_1 = require("@ethersproject/bytes");
const utf8_1 = require("@ethersproject/strings/lib/utf8");
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const lodash_1 = __importDefault(require("lodash"));
const package_json_1 = require("../../package.json");
const index_1 = require("../index");
exports.DEFAULT_COMPONENT_NAME = "data-packages-wrapper";
class ContractParamsProvider {
    requestParams;
    cache;
    overrideRequestParamsPackagesIds;
    constructor(requestParams, cache, overrideRequestParamsPackagesIds) {
        this.requestParams = requestParams;
        this.cache = cache;
        this.overrideRequestParamsPackagesIds = overrideRequestParamsPackagesIds;
    }
    copyForFeedId(feedId) {
        return this.copyForFeedIds([feedId]);
    }
    copyWithOverriddenFeedIds(feedIds) {
        return new ContractParamsProvider(this.requestParams, this.cache, feedIds);
    }
    copyForFeedIds(feedIds) {
        return new ContractParamsProvider({
            ...this.requestParams,
            dataPackagesIds: feedIds,
            returnAllPackages: false,
        }, this.cache);
    }
    static hexlifyFeedIds(feedIds, allowMissingPrefix, padRightSize) {
        return feedIds
            .map((feed) => (0, bytes_1.hexlify)((0, utf8_1.toUtf8Bytes)(feed)), { allowMissingPrefix })
            .map((value) => padRightSize
            ? value.padEnd(padRightSize * 2 + (value.startsWith("0x") ? 2 : 0), "0")
            : value);
    }
    static unhexlifyFeedId(hexlifiedFeedId) {
        return ethers_1.utils.toUtf8String(hexlifiedFeedId).replace(/\0+$/, "");
    }
    async getPayloadHex(withPrefix = true, unsignedMetadataArgs) {
        return ((withPrefix ? "0x" : "") +
            (await this.requestPayload(unsignedMetadataArgs)));
    }
    async getPayloadData(unsignedMetadataArgs) {
        return Array.from((0, utils_1.arrayify)(await this.getPayloadHex(true, unsignedMetadataArgs)));
    }
    getHexlifiedFeedIds(allowMissingPrefix, padRightSize) {
        return ContractParamsProvider.hexlifyFeedIds(this.getDataFeedIds(), allowMissingPrefix, padRightSize);
    }
    getDataFeedIds() {
        return (this.overrideRequestParamsPackagesIds ??
            this.requestParams.dataPackagesIds);
    }
    async requestDataPackages(canUpdateCache = false) {
        const cachedResponse = this.cache?.get(this.requestParams, !canUpdateCache);
        if (cachedResponse) {
            return cachedResponse;
        }
        const dataPackagesResponse = await this.performRequestingDataPackages();
        if (canUpdateCache) {
            this.cache?.update(dataPackagesResponse, this.requestParams);
        }
        return dataPackagesResponse;
    }
    async performRequestingDataPackages() {
        return await (0, index_1.requestDataPackages)(this.requestParams);
    }
    async requestPayload(unsignedMetadataArgs) {
        return (0, index_1.convertDataPackagesResponse)(await this.requestDataPackages(), "string", ContractParamsProvider.getUnsignedMetadata(unsignedMetadataArgs));
    }
    async prepareSplitPayloads(unsignedMetadataArgs) {
        const dataPackagesResponse = await this.requestDataPackages();
        const result = {};
        for (const feedId of this.getDataFeedIds()) {
            const dataPackages = (0, index_1.extractSignedDataPackagesForFeedId)(dataPackagesResponse, feedId);
            if (!dataPackages.length) {
                result[feedId] = undefined;
                continue;
            }
            result[feedId] = (0, index_1.convertDataPackagesResponse)({ [feedId]: dataPackages }, "string", ContractParamsProvider.getUnsignedMetadata(unsignedMetadataArgs));
        }
        return result;
    }
    static extractMissingValues(payloads, logger) {
        const missingFeedIds = lodash_1.default.keys(lodash_1.default.pickBy(payloads, (value) => value === undefined));
        const filteredPayloads = lodash_1.default.omitBy(payloads, (value) => value === undefined);
        if (missingFeedIds.length) {
            logger?.warn(`No data packages found for [${missingFeedIds.toString()}]`);
        }
        return { missingFeedIds, payloads: filteredPayloads };
    }
    static getUnsignedMetadata(args) {
        if (!args) {
            return undefined;
        }
        return `${args.metadataTimestamp ?? Date.now()}#${package_json_1.version}#${args.componentName ?? exports.DEFAULT_COMPONENT_NAME}`;
    }
}
exports.ContractParamsProvider = ContractParamsProvider;
//# sourceMappingURL=ContractParamsProvider.js.map