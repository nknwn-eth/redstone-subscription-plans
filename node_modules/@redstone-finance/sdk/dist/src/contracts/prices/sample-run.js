"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sampleRun = sampleRun;
exports.convertValue = convertValue;
exports.describeTimestamp = describeTimestamp;
exports.describeContractData = describeContractData;
exports.isExtendedPricesContractAdapter = isExtendedPricesContractAdapter;
exports.isMultiFeedContractAdapter = isMultiFeedContractAdapter;
const utils_1 = require("@redstone-finance/utils");
const ethers_1 = require("ethers");
async function sampleRun(paramsProvider, pricesConnector, ethFeedConnector, refreshStateCallback = async () => { }) {
    const pricesAdapter = await pricesConnector.getAdapter();
    await executePullModel(pricesAdapter, paramsProvider);
    const blockNumber = await executePushModel(pricesAdapter, paramsProvider, pricesConnector, refreshStateCallback);
    if (isMultiFeedContractAdapter(pricesAdapter)) {
        await readFromMultiFeedPriceAdapter(pricesAdapter, paramsProvider, blockNumber);
    }
    if (isExtendedPricesContractAdapter(pricesAdapter)) {
        await readFromExtendedPriceAdapter(pricesAdapter, paramsProvider, blockNumber);
    }
    if (ethFeedConnector) {
        await readFromEthFeed(ethFeedConnector);
    }
    logHeader("FINISHING");
}
function logHeader(text, lineSize = 80) {
    console.log("");
    console.log("=".repeat(lineSize));
    console.log(text.toUpperCase());
    console.log("-".repeat(lineSize));
}
async function executePullModel(pricesAdapter, paramsProvider) {
    logHeader("Pulling values using core model");
    try {
        const coreValues = await pricesAdapter.getPricesFromPayload(paramsProvider);
        console.log(`Core values: ${coreValues.map(convertValue)}`);
    }
    catch (e) {
        console.error(utils_1.RedstoneCommon.stringifyError(e));
    }
}
async function executePushModel(pricesAdapter, paramsProvider, pricesConnector, refreshStateCallback) {
    logHeader("Pushing values using classic model");
    const deployHash = await pricesAdapter.writePricesFromPayloadToContract(paramsProvider);
    if (typeof deployHash == "string") {
        await pricesConnector.waitForTransaction(deployHash);
    }
    else {
        console.log(`Values pushed to contract: ${deployHash}`);
    }
    await refreshStateCallback();
    const blockNumber = await pricesConnector.getBlockNumber();
    console.log(`Current block number: ${blockNumber}`);
    logHeader("Viewing values from contract");
    const values = await pricesAdapter.readPricesFromContract(paramsProvider, blockNumber);
    console.log(`Values read from contract: ${values.map(convertValue)}`);
    const readTimestamp = await pricesAdapter.readTimestampFromContract(paramsProvider.getDataFeedIds()[0], blockNumber);
    console.log(`Timestamp read from contract: ${readTimestamp} (${describeTimestamp(readTimestamp)})`);
    return blockNumber;
}
async function readFromMultiFeedPriceAdapter(pricesAdapter, paramsProvider, blockNumber) {
    console.log(`Price data: \n${describeContractData(await pricesAdapter.readContractData(paramsProvider.getDataFeedIds(), blockNumber))}`);
}
async function readFromExtendedPriceAdapter(pricesAdapter, paramsProvider, blockNumber) {
    const lastUpdateBlockTimestamp = await pricesAdapter.readLatestUpdateBlockTimestamp(paramsProvider.getDataFeedIds()[0], blockNumber);
    console.log(`Last update block timestamp: ${lastUpdateBlockTimestamp} (${describeTimestamp(lastUpdateBlockTimestamp)})`);
    const uniqueSignerThreshold = await pricesAdapter.getUniqueSignerThreshold(blockNumber);
    console.log(`Unique signer count: ${uniqueSignerThreshold}`);
}
async function readFromEthFeed(ethFeedConnector) {
    const feedAdapter = await ethFeedConnector.getAdapter();
    const description = feedAdapter.getDescription
        ? await feedAdapter.getDescription()
        : "ETH PriceFeed";
    logHeader(`Viewing data from [${description}]`);
    const { value, timestamp } = await feedAdapter.getPriceAndTimestamp();
    const feedId = feedAdapter.getDataFeedId
        ? await feedAdapter.getDataFeedId()
        : "ETH";
    console.log(`${feedId} price: $${convertValue(value)} (${describeTimestamp(timestamp)})`);
}
function convertValue(v) {
    return ethers_1.BigNumber.from(v).toNumber() / 10 ** 8;
}
function describeTimestamp(timestamp) {
    return `${(Date.now() - timestamp) / 1000} sec. ago`;
}
function describeContractData(data) {
    return Object.entries(data)
        .map(([key, value]) => `${key}: ${convertValue(value.lastValue)} of ${describeTimestamp(value.lastDataPackageTimestampMS)} / block: ${describeTimestamp(value.lastBlockTimestampMS)}`)
        .join("\n");
}
function isExtendedPricesContractAdapter(priceAdapter) {
    const adapter = priceAdapter;
    return (typeof adapter.getUniqueSignerThreshold === "function" &&
        typeof adapter.readLatestUpdateBlockTimestamp === "function");
}
function isMultiFeedContractAdapter(priceAdapter) {
    const adapter = priceAdapter;
    return typeof adapter.readContractData === "function";
}
//# sourceMappingURL=sample-run.js.map