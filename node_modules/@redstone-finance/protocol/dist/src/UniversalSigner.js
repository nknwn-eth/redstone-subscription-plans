"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UniversalSigner = void 0;
const bytes_1 = require("@ethersproject/bytes");
const utils_1 = require("ethers/lib/utils");
const secp256k1_1 = require("secp256k1");
const RS_SIGNATURE_LENGTH = 64;
const ECDSA_N_DIV_2 = BigInt("0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0");
class UniversalSigner {
    static isSignatureVerificationSkipped = false;
    static getDigestForData(data) {
        const message = JSON.stringify(data);
        return (0, utils_1.keccak256)((0, utils_1.toUtf8Bytes)(message));
    }
    static signStringifiableData(data, privateKey) {
        const digest = UniversalSigner.getDigestForData(data);
        const signingKey = new utils_1.SigningKey(privateKey);
        const fullSignature = signingKey.signDigest(digest);
        return (0, utils_1.joinSignature)(fullSignature);
    }
    static recoverSigner(data, signature) {
        const digest = (0, utils_1.arrayify)(UniversalSigner.getDigestForData(data));
        const publicKey = UniversalSigner.recoverPublicKey(digest, signature);
        return (0, utils_1.computeAddress)(publicKey);
    }
    static recoverPublicKey(digest, signature) {
        const sig = this.verifyAndSplitSignature(signature);
        return (0, secp256k1_1.ecdsaRecover)((0, utils_1.arrayify)(sig.r + sig.s.substring(2)), sig.recoveryParam, digest, false);
    }
    static verifyAndSplitSignature(signature) {
        if (UniversalSigner.isSignatureVerificationSkipped) {
            return (0, bytes_1.splitSignature)(signature);
        }
        let v;
        if ((0, bytes_1.isBytesLike)(signature)) {
            const signatureString = (0, utils_1.hexlify)(signature).substring(2);
            v = parseInt(signatureString.substring(2 * RS_SIGNATURE_LENGTH), 16);
        }
        else {
            v = signature.v;
        }
        if (v !== 27 && v !== 28) {
            throw new Error(`Invalid signature 'v' value - must be 27 or 28 but is: ${v}`);
        }
        const sig = (0, bytes_1.splitSignature)(signature);
        if (BigInt(sig.s) > ECDSA_N_DIV_2) {
            throw new Error("Invalid signature 's' value");
        }
        return sig;
    }
    static signWithEthereumHashMessage(signerOrWallet, message) {
        return signerOrWallet.signMessage(message);
    }
    static recoverAddressFromEthereumHashMessage(message, signature) {
        this.verifyAndSplitSignature(signature);
        return (0, utils_1.verifyMessage)(message, signature);
    }
}
exports.UniversalSigner = UniversalSigner;
//# sourceMappingURL=UniversalSigner.js.map