"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertDataPointToNumericDataPoint = exports.RedstonePayloadParser = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const redstone_constants_1 = require("../common/redstone-constants");
const utils_2 = require("../common/utils");
const DataPackage_1 = require("../data-package/DataPackage");
const SignedDataPackage_1 = require("../data-package/SignedDataPackage");
const DataPoint_1 = require("../data-point/DataPoint");
const NumericDataPoint_1 = require("../data-point/NumericDataPoint");
class RedstonePayloadParser {
    bytesData;
    constructor(bytesData) {
        this.bytesData = bytesData;
    }
    parse() {
        this.assertValidRedstoneMarker();
        const unsignedMetadata = this.extractUnsignedMetadata();
        let negativeOffset = unsignedMetadata.length +
            redstone_constants_1.UNSIGNED_METADATA_BYTE_SIZE_BS +
            redstone_constants_1.REDSTONE_MARKER_BS;
        const numberOfDataPackages = this.extractNumber({
            negativeOffset,
            length: redstone_constants_1.DATA_PACKAGES_COUNT_BS,
        });
        negativeOffset += redstone_constants_1.DATA_PACKAGES_COUNT_BS;
        const signedDataPackages = [];
        for (let i = 0; i < numberOfDataPackages; i++) {
            const signedDataPackage = this.extractSignedDataPackage(negativeOffset);
            signedDataPackages.push(signedDataPackage);
            negativeOffset += signedDataPackage.toBytes().length;
        }
        const remainderPrefix = this.slice({
            negativeOffset,
            length: this.bytesData.length - negativeOffset,
        });
        signedDataPackages.reverse();
        return {
            signedDataPackages,
            unsignedMetadata,
            remainderPrefix,
        };
    }
    extractUnsignedMetadata() {
        const unsignedMetadataSize = this.extractNumber({
            negativeOffset: redstone_constants_1.REDSTONE_MARKER_BS,
            length: redstone_constants_1.UNSIGNED_METADATA_BYTE_SIZE_BS,
        });
        return this.slice({
            negativeOffset: redstone_constants_1.REDSTONE_MARKER_BS + redstone_constants_1.UNSIGNED_METADATA_BYTE_SIZE_BS,
            length: unsignedMetadataSize,
        });
    }
    assertValidRedstoneMarker() {
        const redstoneMarker = this.slice({
            negativeOffset: 0,
            length: redstone_constants_1.REDSTONE_MARKER_BS,
        });
        const redstoneMarkerHex = (0, utils_1.hexlify)(redstoneMarker);
        if (redstoneMarkerHex !== redstone_constants_1.REDSTONE_MARKER_HEX) {
            throw new Error(`Received invalid redstone marker: ${redstoneMarkerHex}`);
        }
    }
    extractSignedDataPackage(initialNegativeOffset) {
        let negativeOffset = initialNegativeOffset;
        const signature = this.slice({
            negativeOffset,
            length: redstone_constants_1.SIGNATURE_BS,
        });
        negativeOffset += redstone_constants_1.SIGNATURE_BS;
        const dataPointsCount = this.extractNumber({
            negativeOffset,
            length: redstone_constants_1.DATA_POINTS_COUNT_BS,
        });
        negativeOffset += redstone_constants_1.DATA_POINTS_COUNT_BS;
        const dataPointsValueSize = this.extractNumber({
            negativeOffset,
            length: redstone_constants_1.DATA_POINT_VALUE_BYTE_SIZE_BS,
        });
        negativeOffset += redstone_constants_1.DATA_POINT_VALUE_BYTE_SIZE_BS;
        const timestamp = this.extractNumber({
            negativeOffset,
            length: redstone_constants_1.TIMESTAMP_BS,
        });
        negativeOffset += redstone_constants_1.TIMESTAMP_BS;
        const dataPoints = [];
        let dataPackageId;
        for (let i = 0; i < dataPointsCount; i++) {
            const dataPointValue = this.slice({
                negativeOffset,
                length: dataPointsValueSize,
            });
            negativeOffset += dataPointsValueSize;
            const dataFeedId = this.slice({
                negativeOffset,
                length: redstone_constants_1.DATA_FEED_ID_BS,
            });
            negativeOffset += redstone_constants_1.DATA_FEED_ID_BS;
            const dataPoint = RedstonePayloadParser.createDataPoint(dataFeedId, dataPointValue);
            if (!dataPackageId) {
                dataPackageId = dataPoint.dataFeedId;
            }
            else if (dataPackageId !== dataPoint.dataFeedId) {
                dataPackageId = "__MULTI_POINT__";
            }
            dataPoints.unshift(dataPoint);
        }
        if (!dataPackageId) {
            dataPackageId = "__EMPTY__";
        }
        return new SignedDataPackage_1.SignedDataPackage(new DataPackage_1.DataPackage(dataPoints, timestamp, dataPackageId), (0, utils_1.hexlify)(signature));
    }
    static createDataPoint(dataFeedId, dataPointValue) {
        return new DataPoint_1.DataPoint((0, utils_1.toUtf8String)(dataFeedId).replaceAll("\x00", ""), dataPointValue);
    }
    extractNumber(sliceConfig) {
        const bytesArr = this.slice(sliceConfig);
        return (0, utils_2.convertBytesToNumber)(bytesArr);
    }
    slice(sliceConfig) {
        const { negativeOffset, length } = sliceConfig;
        const end = this.bytesData.length - negativeOffset;
        const start = end - length;
        return this.bytesData.slice(start, end);
    }
}
exports.RedstonePayloadParser = RedstonePayloadParser;
const convertDataPointToNumericDataPoint = (dataPoint, decimals) => new NumericDataPoint_1.NumericDataPoint({
    value: Number((0, utils_1.formatUnits)(ethers_1.BigNumber.from(dataPoint.value), decimals ?? redstone_constants_1.DEFAULT_NUM_VALUE_DECIMALS)),
    dataFeedId: dataPoint.dataFeedId,
    decimals,
});
exports.convertDataPointToNumericDataPoint = convertDataPointToNumericDataPoint;
//# sourceMappingURL=RedstonePayloadParser.js.map