"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.concat = exports.hexlifyWithout0xPrefix = exports.convertBytesToNumber = exports.convertIntegerNumberToBytes = exports.convertNumberToString = exports.convertNumberToBytes = exports.convertStringToBytes32 = exports.assert = void 0;
exports.useDefaultIfUndefined = useDefaultIfUndefined;
const decimal_js_1 = __importDefault(require("decimal.js"));
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const ZERO_EX_PREFIX_LENGTH = 2;
const assert = (condition, errMsg) => {
    if (!condition) {
        const errText = `Assertion failed` + (errMsg ? `: ${errMsg}` : "");
        throw new Error(errText);
    }
};
exports.assert = assert;
const convertStringToBytes32 = (str) => {
    let bytes32Str;
    if (str.length > 31) {
        bytes32Str = (0, utils_1.keccak256)((0, utils_1.isHexString)(str) ? str : (0, utils_1.toUtf8Bytes)(str));
    }
    else {
        bytes32Str = (0, utils_1.formatBytes32String)(str);
    }
    return (0, utils_1.arrayify)(bytes32Str);
};
exports.convertStringToBytes32 = convertStringToBytes32;
const convertNumberToBytes = (value, decimals, byteSize) => {
    const stringifiedNumber = (0, exports.convertNumberToString)(value, decimals);
    const bigNumberValue = (0, utils_1.parseUnits)(stringifiedNumber, decimals);
    const bytesValue = (0, utils_1.arrayify)(bigNumberValue.toHexString());
    if (byteSize < bytesValue.length) {
        throw new Error(`Overflow: ` +
            `value: ${value}, ` +
            `decimals: ${decimals}, ` +
            `byteSize: ${byteSize}`);
    }
    else {
        return (0, utils_1.zeroPad)(bytesValue, byteSize);
    }
};
exports.convertNumberToBytes = convertNumberToBytes;
const convertNumberToString = (value, decimals) => {
    if (typeof value === "string") {
        const decimalValue = new decimal_js_1.default(value);
        return decimalValue.toFixed(decimals);
    }
    const stringifiedNumber = Number(value).toFixed(decimals);
    if (!stringifiedNumber.includes("e")) {
        return stringifiedNumber;
    }
    return Number(stringifiedNumber).toLocaleString("fullwide", {
        useGrouping: false,
    });
};
exports.convertNumberToString = convertNumberToString;
const convertIntegerNumberToBytes = (value, byteSize) => {
    (0, exports.assert)(Number.isInteger(Number(value)), "convertIntegerNumberToBytes expects integer as input");
    const decimals = 0;
    return (0, exports.convertNumberToBytes)(value, decimals, byteSize);
};
exports.convertIntegerNumberToBytes = convertIntegerNumberToBytes;
const convertBytesToNumber = (bytes) => ethers_1.BigNumber.from(bytes).toNumber();
exports.convertBytesToNumber = convertBytesToNumber;
const hexlifyWithout0xPrefix = (value) => {
    return (0, utils_1.hexlify)(value).slice(ZERO_EX_PREFIX_LENGTH);
};
exports.hexlifyWithout0xPrefix = hexlifyWithout0xPrefix;
function useDefaultIfUndefined(value, defaultValue) {
    return value ?? defaultValue;
}
const concat = (items) => {
    const length = items.reduce((acc, item) => acc + item.length, 0);
    const result = new Uint8Array(length);
    items.reduce((offset, item) => {
        result.set(item, offset);
        return offset + item.length;
    }, 0);
    return result;
};
exports.concat = concat;
//# sourceMappingURL=utils.js.map